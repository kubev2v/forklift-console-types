/**
 * 
 * 
 *
 * The version of the OpenAPI document: 
 * Contact Email: 
 * License: 
 *
 * NOTE: This file is auto generated by crdtotypes (https://github.com/yaacov/crdtoapi/).
 * https://github.com/yaacov/crdtoapi/README.crdtotypes
 */

import { V1beta1MigrationStatusVmsConditions } from './V1beta1MigrationStatusVmsConditions';
import { V1beta1MigrationStatusVmsError } from './V1beta1MigrationStatusVmsError';
import { V1beta1MigrationStatusVmsHooks } from './V1beta1MigrationStatusVmsHooks';
import { V1beta1MigrationStatusVmsLuks } from './V1beta1MigrationStatusVmsLuks';
import { V1beta1MigrationStatusVmsPipeline } from './V1beta1MigrationStatusVmsPipeline';
import { V1beta1MigrationStatusVmsWarm } from './V1beta1MigrationStatusVmsWarm';

/**
 * VM Status
 *
 * @export
 */
export interface V1beta1MigrationStatusVms {
  /** completed
   * Completed timestamp.
   *
   * @required {false}
   * @format {date-time}
   */
  completed?: string;
  /** conditions
   * Condition
   *
   * @required {false}
   */
  conditions?: V1beta1MigrationStatusVmsConditions[];
  /** deleteVmOnFailMigration
   * DeleteVmOnFailMigration controls whether the target VM created by this Plan is deleted when a migration fails.
When true and the migration fails after the target VM has been created, the controller
will delete the target VM (and related target-side resources) during failed-migration cleanup
and when the Plan is deleted. When false (default), the target VM is preserved to aid
troubleshooting. The source VM is never modified.

Note: If the Plan-level option is set to true, the VM-level option will be ignored.
   *
   * @required {false}
   */
  deleteVmOnFailMigration?: boolean;
  /** error
   * Errors
   *
   * @required {false}
   */
  error?: V1beta1MigrationStatusVmsError;
  /** firmware
   * The firmware type detected from the OVF file produced by virt-v2v.
   *
   * @required {false}
   */
  firmware?: string;
  /** hooks
   * Plan hook.
   *
   * @required {false}
   */
  hooks?: V1beta1MigrationStatusVmsHooks[];
  /** id
   * The object ID.
vsphere:
  The managed object ID.
   *
   * @required {false}
   */
  id?: string;
  /** instanceType
   * Selected InstanceType that will override the VM properties.
   *
   * @required {false}
   */
  instanceType?: string;
  /** luks
   * Disk decryption LUKS keys
   *
   * @required {false}
   */
  luks?: V1beta1MigrationStatusVmsLuks;
  /** name
   * An object Name.
vsphere:
  A qualified name.
   *
   * @required {false}
   */
  name?: string;
  /** namespace
   * The VM Namespace
Only relevant for an openshift source.
   *
   * @required {false}
   */
  namespace?: string;
  /** nbdeClevis
   * Attempt passphrase-less unlocking for all devices with Clevis, over the network.
Conversion pod running on target cluster will attempt to connect to a TANG server, make sure TANG
server is available on target network.
https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/8/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening
If both nbdeClevis and LUKS are configured, nbdeClevis takes precedence.
   *
   * @required {false}
   */
  nbdeClevis?: boolean;
  /** networkNameTemplate
   * NetworkNameTemplate is a template for generating network interface names in the target virtual machine.
It follows Go template syntax and has access to the following variables:
  - .NetworkName: If target network is multus, name of the Multus network attachment definition, empty otherwise.
  - .NetworkNamespace: If target network is multus, namespace where the network attachment definition is located.
  - .NetworkType: type of the network ("Multus" or "Pod")
  - .NetworkIndex: sequential index of the network interface (0-based)
The template can be used to customize network interface names based on target network configuration.

Provider support:
  - VMware (vSphere): Supported. Network interface names can be customized.
  - OpenShift: Not supported. Network interface names are preserved from the source VM.

Note:
  - This template will override at the plan level template
  - If not specified on VM level and on Plan level, default naming conventions will be used
Examples:
  "net-{{.NetworkIndex}}"
  "{{if eq .NetworkType "Pod"}}pod{{else}}multus-{{.NetworkIndex}}{{end}}"
   *
   * @required {false}
   */
  networkNameTemplate?: string;
  /** newName
   * The new name of the VM after matching DNS1123 requirements.
   *
   * @required {false}
   */
  newName?: string;
  /** operatingSystem
   * The Operating System detected by virt-v2v.
   *
   * @required {false}
   */
  operatingSystem?: string;
  /** phase
   * Phase
   *
   * @required {true}
   */
  phase: string;
  /** pipeline
   * Pipeline step.
   *
   * @required {true}
   */
  pipeline: V1beta1MigrationStatusVmsPipeline[];
  /** pvcNameTemplate
   * PVCNameTemplate is a template for generating PVC names for VM disks.
Generated names must be valid DNS-1123 labels (lowercase alphanumerics, '-' allowed, max 63 chars).
It follows Go template syntax and has access to provider-specific variables.

Common variables (all providers):
  - .VmName: name of the VM in the source cluster (original source name)
  - .TargetVmName: final VM name in the target cluster (may equal .VmName if no rename/normalization)
  - .PlanName: name of the migration plan
  - .DiskIndex: initial volume index of the disk

VMware (vSphere) specific variables:
  - .WinDriveLetter: Windows drive letter (lowercase, if applicable, e.g. "c", requires guest agent)
  - .RootDiskIndex: index of the root disk
  - .Shared: true if the volume is shared by multiple VMs, false otherwise
  - .FileName: name of the file in the source provider (filename includes the .vmdk suffix)

OpenShift specific variables:
  - .SourcePVCName: name of the PVC in the source cluster
  - .SourcePVCNamespace: namespace of the PVC in the source cluster

Note:
  This template overrides the plan level template.
Examples:
  "{{.TargetVmName}}-disk-{{.DiskIndex}}"
  "{{if eq .DiskIndex .RootDiskIndex}}root{{else}}data{{end}}-{{.DiskIndex}}" (VMware)
  "{{.TargetVmName}}-{{.SourcePVCName}}" (OpenShift)
See:
	 https://github.com/kubev2v/forklift/tree/main/pkg/templateutil for template functions.
   *
   * @required {false}
   */
  pvcNameTemplate?: string;
  /** restorePowerState
   * Source VM power state before migration.
   *
   * @required {false}
   */
  restorePowerState?: string;
  /** rootDisk
   * Choose the primary disk the VM boots from
   *
   * @required {false}
   */
  rootDisk?: string;
  /** started
   * Started timestamp.
   *
   * @required {false}
   * @format {date-time}
   */
  started?: string;
  /** targetName
   * TargetName specifies a custom name for the VM in the target cluster.
If not provided, the original VM name will be used and automatically adjusted to meet k8s DNS1123 requirements.
If provided, this exact name will be used instead. The migration will fail if the name is not unique or already in use.
   *
   * @required {false}
   */
  targetName?: string;
  /** targetPowerState
   * TargetPowerState specifies the desired power state of the target VM after migration.
- "on": Target VM will be powered on after migration
- "off": Target VM will be powered off after migration
- "auto" or nil (default): Target VM will match the source VM's power state
   *
   * @required {false}
   * @originalType {string}
   */
  targetPowerState?: 'on' | 'off' | 'auto';
  /** type
   * Type used to qualify the name.
   *
   * @required {false}
   */
  type?: string;
  /** volumeNameTemplate
   * VolumeNameTemplate is a template for generating volume interface names in the target virtual machine.
It follows Go template syntax and has access to the following variables:
  - .PVCName: name of the PVC mounted to the VM using this volume
  - .VolumeIndex: sequential index of the volume interface (0-based)

Provider support:
  - VMware (vSphere): Supported. Default naming is "vol-{index}".
  - OpenShift: Not supported. Volume names are preserved from the source VM.

Note:
  - This template will override at the plan level template
  - If not specified on VM level and on Plan level, default naming conventions will be used
Examples:
  "disk-{{.VolumeIndex}}"
  "pvc-{{.PVCName}}"
   *
   * @required {false}
   */
  volumeNameTemplate?: string;
  /** warm
   * Warm migration status
   *
   * @required {false}
   */
  warm?: V1beta1MigrationStatusVmsWarm;
}
