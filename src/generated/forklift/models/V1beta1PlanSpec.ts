/**
 * 
 * 
 *
 * The version of the OpenAPI document: 
 * Contact Email: 
 * License: 
 *
 * NOTE: This file is auto generated by crdtotypes (https://github.com/yaacov/crdtoapi/).
 * https://github.com/yaacov/crdtoapi/README.crdtotypes
 */

import { V1beta1PlanSpecConvertorAffinity } from './V1beta1PlanSpecConvertorAffinity';
import { V1beta1PlanSpecCustomizationScripts } from './V1beta1PlanSpecCustomizationScripts';
import { V1beta1PlanSpecMap } from './V1beta1PlanSpecMap';
import { V1beta1PlanSpecProvider } from './V1beta1PlanSpecProvider';
import { V1beta1PlanSpecTargetAffinity } from './V1beta1PlanSpecTargetAffinity';
import { V1beta1PlanSpecTransferNetwork } from './V1beta1PlanSpecTransferNetwork';
import { V1beta1PlanSpecVms } from './V1beta1PlanSpecVms';

/**
 * PlanSpec defines the desired state of Plan.
 *
 * @export
 */
export interface V1beta1PlanSpec {
  /** archived
   * Whether this plan should be archived.
   *
   * @required {false}
   */
  archived?: boolean;
  /** conversionTempStorageClass
   * ConversionTempStorageClass specifies the storage class to use for temporary conversion storage.
When specified, virt-v2v conversion pods will use a temporary PVC from this storage class
instead of using the node's ephemeral storage for the conversion scratch space.
This is useful for:
  - Large VM migrations (10+ TB disks) where fstrim operations create large overlays
  - OVA imports that require full uncompressed disk copies in temporary storage
  - Nodes with limited ephemeral storage that may cause pod eviction due to storage pressure
The temporary PVC is automatically created and deleted with the conversion pod.
   *
   * @required {false}
   */
  conversionTempStorageClass?: string;
  /** conversionTempStorageSize
   * ConversionTempStorageSize specifies the size of the temporary conversion storage PVC.
Only used when ConversionTempStorageClass is specified.
User specification allows for buffer space beyond the largest disk size to accommodate:
  - Temporary files during conversion
  - Multiple concurrent conversions
  - OVA imports requiring full uncompressed copies
Recommended minimum: size of the largest VM disk being migrated.
Format: standard Kubernetes resource quantity (e.g., "30Gi", "1Ti")
   *
   * @required {false}
   */
  conversionTempStorageSize?: string;
  /** convertorAffinity
   * ConvertorAffinity allows specifying hard- and soft-affinity for virt-v2v convertor pods.
This can be used to optimize placement for disk conversion performance, such as co-locating
with storage or ensuring network proximity to VMware infrastructure for cold migration data transfers.
See Pod Affinity documentation for more details,
https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
   *
   * @required {false}
   */
  convertorAffinity?: V1beta1PlanSpecConvertorAffinity;
  /** convertorLabels
   * ConvertorLabels are labels that should be applied to the virt-v2v convertor pods.
The convertor pods run virt-v2v to convert VMware disks, install KVM guest agents and drivers,
and handle disk data migration for cold migrations from VMware to KubeVirt.
Note: System-managed labels (migration, plan, vmID, forklift.app) will override any user-defined
labels with the same keys to ensure proper system functionality.
See Pod Labels documentation for more details,
https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#labels
   *
   * @required {false}
   * @originalType {V1beta1PlanSpecConvertorLabels}
   */
  convertorLabels?: {[key: string]: string};
  /** convertorNodeSelector
   * ConvertorNodeSelector constrains the scheduler to only schedule virt-v2v convertor pods on nodes
which contain the specified labels. This is useful for dedicating specific nodes for disk conversion
workloads that require high I/O performance or network access to source VMware infrastructure.
See Pod NodeSelector documentation for more details,
https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
   *
   * @required {false}
   * @originalType {V1beta1PlanSpecConvertorNodeSelector}
   */
  convertorNodeSelector?: {[key: string]: string};
  /** customizationScripts
   * CustomizationScripts references a ConfigMap containing customization scripts
to run during guest conversion. The ConfigMap must exist in the specified
namespace and contain script files with keys following these patterns:
  - Windows: [0-9]+_win_firstboot_[description_text].ps1
  - Linux: [0-9]+_linux_(run|firstboot)_[description_text].sh
Scripts are mounted at /mnt/dynamic_scripts in the conversion pod and
executed by virt-customize. The number at the start of the key determines the
execution order. If not specified, no custom scripts are injected.
   *
   * @required {false}
   */
  customizationScripts?: V1beta1PlanSpecCustomizationScripts;
  /** deleteGuestConversionPod
   * DeleteGuestConversionPod determines if the guest conversion pod should be deleted after successful migration.
Note:
  - If this option is enabled and migration succeeds then the pod will get deleted. However the VM could still not boot and the virt-v2v logs, with additional information, will be deleted alongside guest conversion pod.
  - If migration fails the conversion pod will remain present even if this option is enabled.
   *
   * @required {false}
   */
  deleteGuestConversionPod?: boolean;
  /** deleteVmOnFailMigration
   * DeleteVmOnFailMigration controls whether the target VM created by this Plan is deleted when a migration fails.
When true and the migration fails after the target VM has been created, the controller
will delete the target VM (and related target-side resources) during failed-migration cleanup
and when the Plan is deleted. When false (default), the target VM is preserved to aid
troubleshooting. The source VM is never modified.

Note: If the Plan-level option is set to true, the VM-level option will be ignored.
   *
   * @required {false}
   */
  deleteVmOnFailMigration?: boolean;
  /** description
   * Description
   *
   * @required {false}
   */
  description?: string;
  /** diskBus
   * Deprecated: this field will be deprecated in 2.8.
   *
   * @required {false}
   */
  diskBus?: string;
  /** installLegacyDrivers
   * InstallLegacyDrivers determines whether to install legacy windows drivers in the VM.
The following Vm's are lack of SHA-2 support and need legacy drivers:
Windows XP (all)
Windows Server 2003
Windows Vista (all)
Windows Server 2008
Windows 7 (pre-SP1)
Windows Server 2008 R2
Behavior:
- If set to nil (unset), the system will automatically detect whether the VM requires legacy drivers
  based on its guest OS type (using IsLegacyWindows).
- If set to true, legacy drivers will be installed unconditionally by setting the VIRTIO_WIN environment variable.
- If set to false, legacy drivers will be skipped, and the system will fall back to using the standard (SHA-2 signed) drivers.

When enabled, legacy drivers are exposed to the virt-v2v conversion process via the VIRTIO_WIN environment variable,
which points to the legacy ISO at /usr/local/virtio-win-legacy.iso.
   *
   * @required {false}
   */
  installLegacyDrivers?: boolean;
  /** map
   * Resource mapping.
   *
   * @required {true}
   */
  map: V1beta1PlanSpecMap;
  /** migrateSharedDisks
   * Determines if the plan should migrate shared disks.
   *
   * @required {false}
   * @required {true}
   */
  migrateSharedDisks?: boolean;
  /** networkNameTemplate
   * NetworkNameTemplate is a template for generating network interface names in the target virtual machine.
It follows Go template syntax and has access to the following variables:
  - .NetworkName: If target network is multus, name of the Multus network attachment definition, empty otherwise.
  - .NetworkNamespace: If target network is multus, namespace where the network attachment definition is located.
  - .NetworkType: type of the network ("Multus" or "Pod")
  - .NetworkIndex: sequential index of the network interface (0-based)
The template can be used to customize network interface names based on target network configuration.

Provider support:
  - VMware (vSphere): Supported. Network interface names can be customized.
  - OpenShift: Not supported. Network interface names are preserved from the source VM.

Note:
  - This template can be overridden at the individual VM level
  - If not specified on VM level and on Plan level, default naming conventions will be used
Examples:
  "net-{{.NetworkIndex}}"
  "{{if eq .NetworkType "Pod"}}pod{{else}}multus-{{.NetworkIndex}}{{end}}"
   *
   * @required {false}
   */
  networkNameTemplate?: string;
  /** preserveClusterCpuModel
   * Preserve the CPU model and flags the VM runs with in its oVirt cluster.
   *
   * @required {false}
   */
  preserveClusterCpuModel?: boolean;
  /** preserveStaticIPs
   * Preserve static IPs of VMs in vSphere
   *
   * @required {false}
   * @required {true}
   */
  preserveStaticIPs?: boolean;
  /** provider
   * Providers.
   *
   * @required {true}
   */
  provider: V1beta1PlanSpecProvider;
  /** pvcNameTemplate
   * PVCNameTemplate is a template for generating PVC names for VM disks.
Generated names must be valid DNS-1123 labels (lowercase alphanumerics, '-' allowed, max 63 chars).
It follows Go template syntax and has access to provider-specific variables.

Common variables (all providers):
  - .VmName: name of the VM in the source cluster (original source name)
  - .TargetVmName: final VM name in the target cluster (may equal .VmName if no rename/normalization)
  - .PlanName: name of the migration plan
  - .DiskIndex: initial volume index of the disk

VMware (vSphere) specific variables:
  - .WinDriveLetter: Windows drive letter (lowercase, if applicable, e.g. "c", requires guest agent)
  - .RootDiskIndex: index of the root disk
  - .Shared: true if the volume is shared by multiple VMs, false otherwise
  - .FileName: name of the file in the source provider (filename includes the .vmdk suffix)

OpenShift specific variables:
  - .SourcePVCName: name of the PVC in the source cluster
  - .SourcePVCNamespace: namespace of the PVC in the source cluster

Default behavior when not set:
  - VMware: generates names like "{{trunc 4 .PlanName}}-{{trunc 4 .VmName}}-disk-{{.DiskIndex}}"
  - OpenShift: uses the original source PVC name ("{{.SourcePVCName}}")

Note:
  This template can be overridden at the individual VM level.
Examples:
  "{{.TargetVmName}}-disk-{{.DiskIndex}}"
  "{{if eq .DiskIndex .RootDiskIndex}}root{{else}}data{{end}}-{{.DiskIndex}}" (VMware)
  "{{.TargetVmName}}-{{.SourcePVCName}}" (OpenShift)
See:
	 https://github.com/kubev2v/forklift/tree/main/pkg/templateutil for template functions.
   *
   * @required {false}
   */
  pvcNameTemplate?: string;
  /** pvcNameTemplateUseGenerateName
   * PVCNameTemplateUseGenerateName indicates if the PVC name template should use generateName instead of name.
This field controls whether the template output is used as an exact name or as a prefix for generated names.

Provider-specific behavior:

VMware (vSphere):
  - true (default): Template output is used as generateName prefix, Kubernetes adds a random suffix
    (e.g., "my-vm-disk-0-" becomes "my-vm-disk-0-abc12")
  - false: Template output is used as the exact PVC name
    **DANGER**: May cause conflicts if the generated name is not unique

OpenShift:
  - This field is ignored. The template output is always used as the exact PVC name.
  - Default template "{{.SourcePVCName}}" preserves source PVC names which are typically unique.
   *
   * @required {false}
   * @required {true}
   */
  pvcNameTemplateUseGenerateName?: boolean;
  /** runPreflightInspection
   * RunPreflightInspection controls whether an inspection step on VM base disks is performed before starting the first disk transfer. Applies only to warm migrations from VMWare.
- true (default): Inspection step runs before transferring any disks and may fail if it detects the migration would fail.
- false: No inspection is performed before disk transfer.
   *
   * @required {false}
   * @required {true}
   */
  runPreflightInspection?: boolean;
  /** skipGuestConversion
   * Determines if the plan should skip the guest conversion.
   *
   * @required {false}
   * @required {false}
   */
  skipGuestConversion?: boolean;
  /** skipZoneNodeSelector
   * SkipZoneNodeSelector controls whether to skip adding a zone-based node selector to
migrated VMs. By default, the migration automatically reads the availability zone from
the source provider's spec.settings.target-az configuration and adds a node selector
(topology.kubernetes.io/zone=<target-az>) to the target VM. This ensures VMs are
scheduled on nodes in the same zone as their EBS volumes, which is required for
volume attachment by the CSI driver.
Currently supported for EC2 provider only.
- false (default): Add zone-based node selector using value from provider's spec.settings.target-az
- true: Skip adding zone-based node selector
   *
   * @required {false}
   */
  skipZoneNodeSelector?: boolean;
  /** targetAffinity
   * TargetAffinity allows specifying hard- and soft-affinity for VMs.
it is possible to write matching rules against workloads (VMs and Pods) and Nodes.
Since VMs are a workload type based on Pods, Pod-affinity affects VMs as well.
See virtual machine instance Affinity documentation for more details,
https://kubevirt.io/user-guide/compute/node_assignment/#affinity-and-anti-affinity
   *
   * @required {false}
   */
  targetAffinity?: V1beta1PlanSpecTargetAffinity;
  /** targetLabels
   * TargetLabels are labels that should be applied to the target virtual machines.
Note: System-managed labels (migration, plan, vmID, app) will override any user-defined
labels with the same keys to ensure proper system functionality.
See Pod Labels documentation for more details,
https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#labels
   *
   * @required {false}
   * @originalType {V1beta1PlanSpecTargetLabels}
   */
  targetLabels?: {[key: string]: string};
  /** targetNamespace
   * Target namespace.
   *
   * @required {true}
   */
  targetNamespace: string;
  /** targetNodeSelector
   * TargetNodeSelector, constrains the scheduler to only schedule VMs on nodes,
which contain the specified labels.
See virtual machine instance NodeSelector documentation for more details,
https://kubevirt.io/user-guide/compute/node_assignment/#nodeselector
   *
   * @required {false}
   * @originalType {V1beta1PlanSpecTargetNodeSelector}
   */
  targetNodeSelector?: {[key: string]: string};
  /** targetPowerState
   * TargetPowerState specifies the desired power state of the target VM after migration.
- "on": Target VM will be powered on after migration
- "off": Target VM will be powered off after migration
- "auto" or nil (default): Target VM will match the source VM's power state
   *
   * @required {false}
   * @originalType {string}
   */
  targetPowerState?: 'on' | 'off' | 'auto';
  /** transferNetwork
   * The network attachment definition that should be used for disk transfer.
   *
   * @required {false}
   */
  transferNetwork?: V1beta1PlanSpecTransferNetwork;
  /** type
   * Migration type. e.g. "cold", "warm", "live", "conversion". Supersedes the `warm` boolean if set.
   *
   * @required {false}
   * @originalType {string}
   */
  type?: 'cold' | 'warm' | 'live' | 'conversion';
  /** useCompatibilityMode
   * useCompatibilityMode controls whether to use VirtIO devices when skipGuestConversion is true (Raw Copy mode).
This setting has no effect when skipGuestConversion is false (V2V Conversion always uses VirtIO).
- true (default): Use compatibility devices (SATA bus, E1000E NIC) to ensure bootability
- false: Use high-performance VirtIO devices (requires VirtIO drivers already installed in source VM)
   *
   * @required {false}
   * @required {true}
   */
  useCompatibilityMode?: boolean;
  /** vms
   * A VM listed on the plan.
   *
   * @required {true}
   */
  vms: V1beta1PlanSpecVms[];
  /** volumeNameTemplate
   * VolumeNameTemplate is a template for generating volume interface names in the target virtual machine.
It follows Go template syntax and has access to the following variables:
  - .PVCName: name of the PVC mounted to the VM using this volume
  - .VolumeIndex: sequential index of the volume interface (0-based)

Provider support:
  - VMware (vSphere): Supported. Default naming is "vol-{index}".
  - OpenShift: Not supported. Volume names are preserved from the source VM.

Note:
  - This template can be overridden at the individual VM level
  - If not specified on VM level and on Plan level, default naming conventions will be used
Examples:
  "disk-{{.VolumeIndex}}"
  "pvc-{{.PVCName}}"
   *
   * @required {false}
   */
  volumeNameTemplate?: string;
  /** warm
   * Whether this is a warm migration.
Deprecated: this field will be deprecated in 2.10. Use Type instead.
   *
   * @required {false}
   */
  warm?: boolean;
}
